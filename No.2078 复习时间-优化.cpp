/**
	No.2078 复习时间-优化 
	为了能过个好年，xhd开始复习了，于是每天晚上背着书往教室跑。xhd复习有个习惯，在复习完一门课后，
	他总是挑一门更简单的课进行复习，而他复习这门课的效率为两门课的难度差的平方,而复习第一门课的效率为100
	和这门课的难度差的平方。xhd这学期选了n门课，但是一晚上他最多只能复习m门课，
	请问他一晚上复习的最高效率值是多少？
	
	Input:输入数据的第一行是一个数据T，表示有T组数据。
		每组数据的第一行是两个整数n(1 <= n <= 40)，m(1 <= m <= n)。
		接着有n行，每行有一个正整数a(1 <= a <= 100)，表示这门课的难度值。
		
	Output:对于每组输入数据，输出一个整数，表示最高效率值。
	
	SampleInput:
		2
		2 2
		52
		25
		12 5
		89
		64
		6
		43
		56
		72
		92
		23
		20
		22
		37
		31
	
	SampleOutput:
		5625
		8836
		 
	注：当你看到题时，你在羡慕题出得多么精妙，是利用分治，贪心还是动态规划 呢？
		然而一顿操作猛如虎以后，你发现其实这道题特别的水…关键在于那句'但是一晚上他最多只能复习m门课'上，
		最多为m，那么也就是说我一晚上只复习一科也是可以的，而题的难度又是小于100的，
		所以我一晚上只复习那最简单的一科时复习的效率最高。
**/
# include<iostream>
# include<vector>
# include<cmath> // pow
# include<algorithm> // max() min() sort() 
using namespace std;

int main() {
	//分析后优化 
	//一晚上他最多只能复习m门课，一晚上我可以只复习一科，而题的难度又是小于100的
	//所以，我一晚上只复习那最简单的一科时复习的效率最高 
	int T;
	cin >> T;
	int n,m;
	while(T--) {
		cin >> n >> m;
		vector<int> arr(n);
		for(int i=0; i<n; i++) {
			cin >> arr[i];
		}
		sort(arr.begin(), arr.end()); //从小到大 
		int res = pow(100-arr[0], 2);
		cout << res << endl;
	}
	return 0;
} 
