/**
	No.2044 一只小蜜蜂... 
	有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。
	其中，蜂房的结构如下所示。
		1 3 5 7 9 11 ...
		 2 4 6 8 10 12 ... 
	
	Input:输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0<a<b<50)
	Output:对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行
	
	SampleInput:
		2
		1 2
		3 6
		
	SampleOutput:
		1
		3
	
	解题思路：我们注意到蜜蜂只能前往右侧相邻的蜂房，假设在从第1个到第n（n>2）个蜂房处有f(n)中方案，
	那么我们往左看，在第n个蜂房旁有第n-1和第n-2两个蜂房，且它们直接到达第n个蜂房都只有一种途径，
	而它们对应到达蜂房的方案数为f(n-1)和f(n-2)种，则有如下结论： 
		f(n)=f(n-1)+f(n-2)(n>2)
	对于f(1)和f(2)易知是1和2，则可推出结果。
	而从第a个蜂房到第b个蜂房等价于从第1个蜂房到第(b-a)个蜂房，则所有问题迎刃而解了。 

**/ 
# include<iostream>
# include<vector>
using namespace std;

vector<long long int> dp(51, 0); //改成 long long型，后面大小会超 int型

int main() {
	// 动态规划 ---斐波那契数列 
	int n;
	dp[0] = 1; //0-1 1-2 dp下标从0开始 
	dp[1] = 2;
	for(int i=2; i<51; i++) {
		dp[i] = dp[i-1] + dp[i-2];
	}
	while(cin >> n && n) {
		while(n--) {
			int a,b;
			cin >> a >> b;
			cout << dp[b-a-1] << endl; //注意下标从0开始 
		}
	} 
	return 0;
}
