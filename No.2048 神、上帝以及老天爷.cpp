/**
	No.2048 神、上帝以及老天爷
	HDU 2006'10 ACM contest的颁奖晚会隆重开始了！
	为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：
	
	首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；
	然后，待所有字条加入完毕，每人从箱中取一个字条；
	最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
	
	大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！
	
	我的神、上帝以及老天爷呀，怎么会这样呢？
	
	不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？
	
	不会算？难道你也想以悲剧结尾？！
	
	Input:输入数据的第一行是一个整数 C,表示测试实例的个数，然后是 C行数据，每行包含一个整数n(1<n<=20),表示参加抽奖的人数
	Output:对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照 sample output
	
	SampleInput:
		1
		2
		
	SampleOutput:
		50.00%
	
	解题思路：
		如果前n-1个全拿错，那第n个人随便拿，但不能拿自己的，故有dp[n-1]*(n-1)种情况
		如果前n-1个不满足全拿错，有一个拿了自己的，其余n-2个人满足全拿错的情况，此时只需要将拿了自己的和第n个进行交换，故有dp[n-2]*(n-1) 
		综上，全错排列的递推公式为 dp[n] = (n-1)*(dp[n-1]+dp[n-2])
		又，全错排列 n个人取票的总情况数为 n的阶乘 
		所以概率就为全错排的情况总数/总情况数 = dp[n]/n! 
	
**/ 
# include<iostream>
using namespace std;

double dp[21] = {0};

int main() {
	// 动态规划---全错排列 
	// 如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
	// 计算一下最后没有一个人中奖的概率
	int n;
	dp[0] = 0;
	dp[1] = 0;
	dp[2] = 1;
	for(int i=3; i<=20; i++) {
		dp[i] = (i-1) * (dp[i-1] + dp[i-2]);
	}
	
	while(cin >> n && n) {
		while(n--) {
			double sum = 1;
			int num;
			cin >> num;
			for(int i=1; i<=num; i++) { //求 n! 
				sum *= i;
			}
			printf("%.2f%%\n", (dp[num]/sum)*100);
		}
	} 
	return 0;
}
