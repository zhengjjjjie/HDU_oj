/**
	No.2059 龟兔赛跑-动态规划（正确解法） 
	据说在很久很久以前，可怜的兔子经历了人生中最大的打击――赛跑输给乌龟后，心中郁闷，发誓要报仇雪恨，于是躲进了杭州下沙某农业园卧薪尝胆
	潜心修炼，终于练成了绝技，能够毫不休息得以恒定的速度(VR m/s)一直跑。兔子一直想找机会好好得教训一下乌龟，以雪前耻。
	
	最近正值HDU举办50周年校庆，社会各大名流齐聚下沙，兔子也趁此机会向乌龟发起挑战。
	虽然乌龟深知获胜希望不大，不过迫于舆论压力，只能接受挑战。
	比赛是设在一条笔直的道路上，长度为L米，规则很简单，谁先到达终点谁就算获胜。
	无奈乌龟自从上次获胜以后，成了名龟，被一些八卦杂志称为“动物界的刘翔”，广告不断，手头也有了不少积蓄。
	为了能够再赢兔子，乌龟不惜花下血本买了最先进的武器――“"小飞鸽"牌电动车。这辆车在有电的情况下能够以VT1 m/s的速度“飞驰”，
	可惜电池容量有限，每次充满电最多只能行驶C米的距离，以后就只能用脚来蹬了，乌龟用脚蹬时的速度为VT2 m/s。
	更过分的是，乌龟竟然在跑道上修建了很多很多(N个)的供电站，供自己给电动车充电。其中，每次充电需要花费T秒钟的时间。
	当然，乌龟经过一个充电站的时候可以选择去或不去充电。
	
	比赛马上开始了，兔子和带着充满电的电动车的乌龟并列站在起跑线上。
	你的任务就是写个程序，判断乌龟用最佳的方案进军时，能不能赢了一直以恒定速度奔跑的兔子。
	
	Input:本题目包含多组测试，请处理到文件结束。每个测试包括四行：
		第一行是一个整数L代表跑道的总长度
		第二行包含三个整数N，C，T，分别表示充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间
		第三行也是三个整数VR，VT1，VT2，分别表示兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度
		第四行包含了N(N<=100)个整数p1,p2...pn,分别表示各个充电站离跑道起点的距离，其中0<p1<p2<...<pn<L
		其中每个数都在32位整型范围之内。
	Output:当乌龟有可能赢的时候输出一行 “What a pity rabbit!"。否则输出一行"Good job,rabbit!";
		题目数据保证不会出现乌龟和兔子同时到达的情况。
		
	SampleInput:
		100
		3 20 5
		5 8 2
		10 40 60
		100
		3 60 5
		5 8 2
		10 40 60
		
	SampleOutput:
		Good job,rabbit!
		What a pity rabbit!
		
	错误思路： 
		把每一个充电站的当作一个'状态点'，第i个点的最短时间等于第i-1个点的最短时间加上第i-1个点'充电'与'不充电'两种情况所用时间的较小值
		但是尝试多次后发现结果不对，原来是我的思路有问题。
		由于题目中的各种参数是输入的，所以情况会有很多，就会出现'C'远大于每个充电站之间距离的情况。
		
	正确思路：到达第i个充电站需要的最小时间等于前i-1个已知的充电站时间 + 在其充满电以后一直'坚持'到第i个充电站所需时间的最小值，
			需要注意的是如果从第1个充电站出发是不需要提前充电的（电在比赛之前已经充好了）。
			
			首先将问题转化为：到达一个站点i的最优解。
			对于每一个站点i，我们可以假设在第j(0<j<i)个站点充满电出发，一共有两种状态：
				(1) 当从第j个站点到第i个的距离大于电动车能够行使的距离时，需要开与骑相结合。
				(2) 当从第j个站点到第i个的距离小于电动车能够行使的距离时 ，只需要开到。
				
**/ 
# include<iostream>
# include<algorithm> 
using namespace std;

double dp[102];
double rabbit_time, tortoise_time; //兔子和乌龟到达时间 
double MinT,time;
int p[101];//p[i]表示各个充电站离跑道起点的距离 

int main() {
	// 动态规划 
	int L; //跑道的总长度
	int N,C,T; //充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间
	int VR,VT1,VT2; //兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度
	
	while(cin >> L) {
		cin >> N >> C >> T;
		cin >> VR >> VT1 >> VT2;
		for(int i=1; i<=N; i++) {
			cin >> p[i];
		}
		p[N+1] = L;
		
		dp[0] = 0;//起点是第0个站点，终点是第n+1个站点
		for(int i=1; i<=N+1; i++) {
			MinT = INT_MAX; 
			for(int j=0; j<i; j++) { //j->i 
				// 考虑第j到第i个充电站时，第i充电和不充电的两种情况
				int dis = p[i] - p[j]; 
				if(C >= dis) {
					time = dis*1.0/VT1;
				} else {
					time = C*1.0/VT1 + (dis-C)*1.0/VT2;
				}
				if(j != 0) { //除了起点，充电需要时间 
					time += T; 
				}
				time += dp[j];
				MinT = min(time, MinT); 
			} 
			dp[i] = MinT; //到i的最快时间
		}
		tortoise_time = dp[N+1];
		rabbit_time = L * 1.0 / VR;
		if (tortoise_time > rabbit_time) {
			printf("Good job,rabbit!\n");
		}
        else {
        	printf("What a pity rabbit!\n");
		}
	} 
	return 0;
} 
