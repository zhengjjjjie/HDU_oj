/**
	No.2045 不容易系列之(3)――LELE的RPG难题 
	人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即"可乐"）,
	经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:
	有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．
	求全部的满足要求的涂法.以上就是著名的RPG难题.
	如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?
	
	Input:输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0<n<=50)
	Output:对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行
	
	SampleInput:
		1
		2
		
	SampleOutput:
		3
		6
	
	解题思路： 
	dp[1] = 3 第一个格子有三种情况可选，故 dp[1]=3
	dp[2] = 6 此时第一个格子有三种颜色可选，第二个格子有两种情况，故 dp[2]=3*2=6
	dp[3] = 6 由于最后一个格子颜色不能与首格颜色相同，也不与相邻格子颜色相同，所以最后一个格子只能选一种颜色，即 dp[3]=dp[2]=3*2*1=6
	此时来讨论 n >= 4的情况:
	已知 dp[0]=0, dp[1]=3, dp[2]=6, dp[3]=6
	1、倒数第二个颜色，即第 n-1个格子的颜色与第一个格子颜色不相同，那么此时第 n个格子只能选一种颜色，所以 dp[n]=dp[n-1]*1=dp[n-1]；
	2、倒数第二个颜色，即第 n-1个格子颜色与第一个格子颜色相同，那么此时第 n个格子能选择两种颜色，那么就有 dp[n]=dp[n-2]*2
	（因为第 n-1个格子固定了只能选一个，这个乘二是乘的最后一个格子的可能选择个数）。
	由于1 2两点是第 n-1个格子的分支，所以它们应该相加，最后得出状态转移方程为 dp[n]=dp[n-2]*2+dp[n-1]。

**/ 
# include<iostream>
# include<vector> 
using namespace std;

vector<long long int> dp(51,0);

int main() {
	// 动态规划 
	int n;
	dp[1] = 3;
	dp[2] = 6;
	dp[3] = 6;
	for(int i=4; i<51; i++) {
		 dp[i] = dp[i-2]*2 + dp[i-1];
	}
	while(cin >> n && n) {
		cout << dp[n] << endl;
	}
	return 0;
}
